"use strict";(self.webpackChunkwasmx_docs=self.webpackChunkwasmx_docs||[]).push([[2533],{1634:e=>{e.exports=JSON.parse('{"permalink":"/blog/treechains-heterogeneous-consensus-algorithms","editUrl":"https://github.com/loredanacirstea/wasmx-docs/tree/main/blog/2024-11-24-treechains-heterogeneous-consensus-algorithms.md","source":"@site/blog/2024-11-24-treechains-heterogeneous-consensus-algorithms.md","title":"MythosX - Treechains - heterogeneous consensus algorithms for blockchains [visual finite state machines]","description":"Simple blockchains are dying, long live the trees of blockchains.","date":"2024-11-24T00:00:00.000Z","tags":[{"inline":false,"label":"wasmx","permalink":"/blog/tags/wasmx","description":"wasmx tag description"},{"inline":false,"label":"treechains","permalink":"/blog/tags/treechains","description":"treechains tag description"},{"inline":false,"label":"mythos","permalink":"/blog/tags/mythos","description":"mythos tag description"}],"readingTime":2.78,"hasTruncateMarker":true,"authors":[{"name":"Loredana Cirstea","title":"Lead Engineer @ wasmX","url":"https://github.com/loredanacirstea","page":{"permalink":"/blog/authors/loredana"},"socials":{"x":"https://x.com/lorecirstea","github":"https://github.com/loredanacirstea"},"imageURL":"https://avatars.githubusercontent.com/u/4785356?v=4","key":"loredana"}],"frontMatter":{"slug":"treechains-heterogeneous-consensus-algorithms","title":"MythosX - Treechains - heterogeneous consensus algorithms for blockchains [visual finite state machines]","authors":"loredana","tags":["wasmx","treechains","mythos"]},"unlisted":false,"prevItem":{"title":"why wasmX?","permalink":"/blog/why-wasmx"},"nextItem":{"title":"MythosX - Trees of blockchains - a scaling solution [multichain elective state syncing]","permalink":"/blog/treechains-multichain-elective-state-syncing"}}')},8453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>r});var n=s(6540);const o={},a=n.createContext(o);function i(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(a.Provider,{value:t},e.children)}},9132:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>n,toc:()=>h});var n=s(1634),o=s(4848),a=s(8453);const i={slug:"treechains-heterogeneous-consensus-algorithms",title:"MythosX - Treechains - heterogeneous consensus algorithms for blockchains [visual finite state machines]",authors:"loredana",tags:["wasmx","treechains","mythos"]},r="MythosX: Treechains: heterogeneous consensus algorithms for blockchains",c={authorsImageUrls:[void 0]},h=[];function l(e){const t={p:"p",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Simple blockchains are dying, long live the trees of blockchains."}),"\n",(0,o.jsx)(t.p,{children:"MythosX presents treechains:  heterogeneous consensus algorithms for blockchains as WASM-interpreted graphical finite state machines."}),"\n",(0,o.jsx)(t.p,{children:"Decentralized, immutable, proof-based technology is to Artificial Intelligence what Shiva is to Shakti."}),"\n",(0,o.jsx)(t.p,{children:"The digital world needs grounding, needs boundaries and a solid structure, for intelligence to flow harmoniously."}),"\n",(0,o.jsx)(t.p,{children:"We are building the next-next generation of shivachains."}),"\n",(0,o.jsx)(t.p,{children:"We have talked about trees of blockchains and MythosX and the type of cross-chain transactions that this system enables. You know by now that our systems are WebAssembly based and upgradable."}),"\n",(0,o.jsx)(t.p,{children:"I will show you how MythosX uses a heterogeneous system of consensus algorithms."}),"\n",(0,o.jsx)(t.p,{children:"First, Mythos uses Tendermint, implemented as a finite state machine, interpreted by a WASM contract. This diagram is what runs the protocol. I change this diagram, I change the protocol. In previous videos I've discussed our state machine interpreter and this diagram in detail."}),"\n",(0,o.jsx)(t.p,{children:"Then, for our hierarchical tree chain that grows from the grassroots upwards, we have our LevelX consensus protocol. This is a simplified version of Tendermint. LevelX is the default consensus protocol, but the subchains can use whatever consensus algorithm is available."}),"\n",(0,o.jsx)(t.p,{children:"Then, for our private, node-specific Level0 subchain, we have our Level0 on-demand consensus. Level0 is a private chain that records all node-specific negotiations, configurations, setups and even user chats. So, it does not need to produce blocks all the time. So, it only produces blocks at startup and whenever transactions come.\nMost of the time, it stays in this waiting state. And when it produces a block, it transitions into the Validator state. This protocol is the LevelX protocol. So, we can have a version of Tendermint that does the same thing."}),"\n",(0,o.jsx)(t.p,{children:"And this is a demonstration of this new, on-demand consensus protocol."}),"\n",(0,o.jsx)(t.p,{children:"I have set up two nodes here, with Mythos and Level0. Let's start them and check the level0 logs.\nSo, after initialization, we see a block being produced and then, block production on Level0, stops.\nBut, we have a Lobby contract that negotiates the creation of a level1 subchain with the other node. So, these negotiation transactions trigger Level0 blocks."}),"\n",(0,o.jsx)(t.p,{children:"If we send a transaction, for example a genesis transaction for this level1 subchain, we see it being registered and a block is produced."}),"\n",(0,o.jsx)(t.p,{children:"Otherwise, no blocks are produced on Level0."}),"\n",(0,o.jsx)(t.p,{children:"This family of on-demand consensus algorithms are great for mobile devices. And if you want to increase trust and provability, you can pair them with transactions on a remote chain that produces blocks continuously, so you can root your Level0 chain in time."}),"\n",(0,o.jsx)(t.p,{children:"You can have a variety of consensus protocols that you can test on subchains. Developing new protocols is easy, creating chains programmatically is easy."}),"\n",(0,o.jsx)(t.p,{children:"And anyone can create a subchain without being a developer. This is the system that we are building."}),"\n",(0,o.jsx)(t.p,{children:"A system created for decentralized collaboration and development. Created to scale at network state levels. Created to provide a basis for a new human civilization rooted in the dynamic relationship between blockchain and AI: between Shiva and Shakti."}),"\n",(0,o.jsx)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/4ocX_w_xj0g?si=qDwjOBJ6m7niuZo9",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:!0})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);